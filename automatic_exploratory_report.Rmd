---
title: "POMA: Statistical Analysis Tool for Mass Spectrometry Data"
subtitle: "Exploratory Data Analysis"
date: '`r format(Sys.Date(), "%B, %Y")`'
output:
  prettydoc::html_pretty:
    toc: true
    number_sections: true
    theme: cayman
    highlight: github
params:
  n: NA
---

```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE}
# This file is part of POMA.

# POMA is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# POMA is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with POMA. If not, see <https://www.gnu.org/licenses/>.

library(tidyverse)
library(patchwork)
library(reshape2)
library(knitr)
library(viridis)

data <- params$n
colnames(data)[1:2] <- c("ID", "Group")
```
 
```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE}
samples_group <- data %>% select(ID, Group)
dataX <- data %>% select(-ID, -Group)

# zeros
zeros <- sapply(dataX, function(x) sum(x == 0, na.rm = T))
zeros <- data.frame(number = zeros) %>%
  mutate(names = rownames(.)) %>%
  filter(zeros != 0)

all_zero <- zeros %>% 
  filter(number == ncol(dataX))

# missing values
nas <- sapply(dataX, function(x) sum(is.na(x)))
nas <- data.frame(number = nas[nas != 0]) %>%
  mutate(names = rownames(.))

final_data <- dataX[, !(colnames(dataX) %in% all_zero$names)]
final_data <- cbind(samples_group, final_data)
```

# Know your data

  + Your data has **`r nrow(dataX)`** subjects, **`r ncol(dataX)`** features and **`r length(table(samples_group$Group))`** groups, that are **`r noquote(paste(shQuote(levels(as.factor(samples_group$Group))), collapse=", "))`**.    

  + A **`r round(sum(is.na(dataX))/(nrow(dataX)*(ncol(dataX)))*100, 3)`%** of the values in your data are NAs (missing values). `r ifelse(nrow(nas) >= 1, paste0("The variables that have NA values are **",noquote(paste(shQuote(paste0(nas$names," (",nas$number,")")), collapse=", ")),"**."), "")`

  + A **`r round(sum(zeros$number)/(nrow(dataX)*(ncol(dataX)))*100, 3)`%** of the values in your data are zeros. `r ifelse(nrow(zeros) >= 1, paste0("The variables that have zeros are **",noquote(paste(shQuote(paste0(zeros$names," (",zeros$number,")")), collapse=", ")),"**."), "")`
  
  + Removed from the exploratory analysis **`r nrow(all_zero)`** features that only have zeros. `r ifelse(nrow(all_zero) >= 1, paste0("These variables are **",noquote(paste(shQuote(all_zero$names), collapse=", ")),"**."), "")`

## Summary Table

```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE}
summary_table1 <- data.frame(NumberOfSamples = nrow(dataX),
                             NumberOfFeatures = ncol(dataX))
summary_table2 <- data.frame(NumberOfZeros = sum(zeros$number),
                             PercentageOfZeros = paste(round(sum(zeros$number)/(nrow(dataX)*(ncol(dataX)))*100, 3), "%"))
summary_table3 <- data.frame(NumberOfNA = sum(is.na(dataX)),
                             PercentageOfNA = paste(round(sum(is.na(dataX))/(nrow(dataX)*(ncol(dataX)))*100, 3), "%")) 
kable(summary_table1)
kable(summary_table2)
kable(summary_table3)
```

```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE, dpi = 300}
if (nrow(nas) >= 1){
  ggplot(nas, aes(reorder(names, number), number, fill = number)) +
    geom_col() +
    ylab("Missing values") +
    xlab("") +
    ggtitle("Missing Value Plot") +
    theme_bw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "none")
}
```

```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE, dpi = 300}
if (nrow(zeros) >= 1){
  ggplot(zeros, aes(reorder(names, number), number, fill = number)) +
    geom_col() +
    ylab("Zeros") +
    xlab("") +
    ggtitle("Zeros Plot") +
    theme_bw() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "none")
}
```

## Samples by Group

```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE, dpi = 300}
counts <- data.frame(table(samples_group$Group))
colnames(counts) <- c("Group", "Counts")

ggplot(counts, aes(reorder(Group, Counts), Counts, fill = Group)) +
  geom_col() +
  ylab("Counts") +
  xlab("") +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")
```

# Variable Distribution

## Boxplots

```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE, dpi = 300}
indNum <- nrow(final_data)

p1 <- final_data %>%
  reshape2::melt() %>%
  group_by(ID) %>%
  ggplot(aes(ID, value, color = Group)) +
  geom_boxplot() +
  {if(indNum < 11)geom_jitter()} +
  theme_bw() +
  xlab("") +
  ylab("Value") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p2 <- final_data %>%
  reshape2::melt() %>%
  group_by(ID) %>%
  ggplot(aes(ID, log2(value), color = Group)) +
  geom_boxplot() +
  {if(indNum < 11)geom_jitter()} +
  theme_bw() +
  xlab("Samples") +
  ylab("log2(Value)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p1/p2
```

```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE, eval = F}
## Check Normality and Homogeneity

normality <- data.frame(pval = apply(data[,3:ncol(final_data)], 2, function(x) {shapiro.test(x)$p.value}))
normality$pval <- p.adjust(normality$pval, method = "fdr")
percent.norm <- round((length(normality[normality$pval > 0.05,])/nrow(normality))*100,3)

normality$names <- rownames(normality)
names.normality <- normality[normality$pval > 0.05,2]

##

homo <- data.frame(pval=apply(data[,3:ncol(data)],2,function(x) {bartlett.test(x, samples_group$Group)$p.value}))
homo$pval <- p.adjust(homo$pval, method = "fdr")
percent.homo <- round((length(homo[homo$pval > 0.05,])/nrow(homo))*100,3)

homo$names <- rownames(homo)
names.homo <- homo[homo$pval > 0.05,2]

  + **`r nrow(normality[normality$pval > 0.05,])`** out of your **`r nrow(normality)`** variables (**`r percent.norm`%**) have a normal distribution before log transformation. `r ifelse(nrow(normality[normality$pval > 0.05,]) >= 1, paste0("This variables are **",noquote(paste(shQuote(names.normality), collapse=", ")),"**."), "")`
  
  + **`r nrow(homo[homo$pval > 0.05,])`** out of your **`r nrow(homo)`** variables (**`r percent.homo`%**) have homoskedasticity before log transformation. `r ifelse(nrow(homo[homo$pval > 0.05,]) >= 1, paste0("This variables are **",noquote(paste(shQuote(names.homo), collapse=", ")),"**."), "")`
```
  
## Density plots by Group

```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE, dpi = 300}
p3 <- final_data %>%
  reshape2::melt() %>%
  ggplot(aes(value, fill = Group, colour = Group)) +
    geom_density(alpha = 0.5) + 
    theme_bw() + 
    xlab("Value") +
    ylab("Density")

p4 <- final_data %>%
  reshape2::melt() %>%
  ggplot(aes(log2(value), fill = Group, colour = Group)) +
    geom_density(alpha = 0.5) + 
    theme_bw() + 
    xlab("log2(Value)") +
    ylab("Density")

p3/p4
```

# High Correlated Variables (r > 0.97)

```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE}
X <- as.matrix(final_data[, 3:ncol(final_data)])

#### dummy imputation

X[X == 0] <- NA
X <- apply(X, 2, function(x) {if(is.numeric(x)) ifelse(is.na(x), min(x, na.rm = T)/2, x) else x})

####

mycorr <- cor(X)
mycorr <- which(mycorr > 0.97 & mycorr != 1, arr.ind = TRUE) 
```

There are **`r nrow(mycorr)`** high correlated features in your data. `r ifelse(nrow(mycorr) >= 1, paste0("These features are **",noquote(paste(shQuote(rownames(mycorr)), collapse=", ")),"**."), "")`

# Volcano Plot

```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE, dpi = 300}
X <- as.matrix(final_data[, 3:ncol(final_data)])
Group <- as.factor(final_data$Group) 

#### dummy imputation

X[X == 0] <- NA
X <- apply(X, 2, function(x) {if(is.numeric(x)) ifelse(is.na(x), min(x, na.rm = T)/2, x) else x})

####

stat <- function(x) {
    t.test(x ~ Group, na.rm = TRUE, alternative = c("two.sided"), 
           var.equal = F, 
           paired = F)$p.value
  }
  
stat_G2 <- function(x) {
  t.test(x ~ Group, na.rm = TRUE, alternative = c("two.sided"), 
         var.equal = F)$estimate[[2]]
}

stat_G1 <- function(x) {
  t.test(x ~ Group, na.rm = TRUE, alternative = c("two.sided"), 
         var.equal = F)$estimate[[1]]
}

p <- data.frame(pvalue = apply(FUN = stat, MARGIN = 2, X = X))

p <- p %>% 
  rownames_to_column("feature") %>% 
  as_tibble() %>% 
  mutate(pvalue_Adj = p.adjust(pvalue, method = "fdr")) %>% 
  column_to_rownames("feature")

G2 <- round(data.frame(Mean_G2 = apply(FUN = stat_G2, MARGIN = 2, X = X)), 3)
G1 <- round(data.frame(Mean_G1 = apply(FUN = stat_G1, MARGIN = 2, X = X)), 3)

means <- cbind(G1, G2)

means <- means %>% 
  rownames_to_column("feature") %>% 
  mutate(Fold_Change_Ratio = as.numeric(round(Mean_G2/Mean_G1, 3)), 
         Difference_Of_Means = as.numeric(round(Mean_G1 - Mean_G2, 3))) %>% 
  column_to_rownames("feature")
df <- cbind(means, p)

####

names <- colnames(X)

df <- data.frame(pvalue = df$pvalue, FC = log2(df$Fold_Change_Ratio), names = names)

df <- mutate(df, threshold = as.factor(ifelse(df$pvalue >= 0.05,
                                              yes = "none",
                                              no = ifelse(df$FC < log2(1.5),
                                                          yes = ifelse(df$FC < -log2(1.5),
                                                                       yes = "Down-regulated",
                                                                       no = "none"),
                                                          no = "Up-regulated"))))

ggplot(data = df, aes(x = FC, y = -log10(pvalue), colour = threshold, label = names)) +
  geom_point(size=1.75) +
  xlim(c(-3, 3)) +
  xlab("log2 Fold Change") +
  ylab("-log10 p-value") +
  scale_y_continuous(trans = "log1p")+
  ggtitle(paste0("Comparisson: ", names(table(samples_group$Group))[2], "/",
                 names(table(samples_group$Group))[1])) +
  geom_vline(xintercept = -log2(1.5), colour = "black", linetype = "dashed") +
  geom_vline(xintercept = log2(1.5), colour = "black", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), colour = "black", linetype = "dashed") +
  theme(legend.position = "none") +
  theme_bw() +
  scale_color_manual(values = c("Down-regulated" = "#E64B35", "Up-regulated" = "#3182bd", "none" = "#636363"))
```

# Principal Component Analysis

```{r, echo = FALSE, warning = FALSE, comment = NA, message = FALSE, dpi = 300}
X <- as.matrix(final_data[, 3:ncol(final_data)])
Y <- as.factor(final_data$Group) 

#### dummy imputation

X[X == 0] <- NA
X <- apply(X, 2, function(x) {if(is.numeric(x)) ifelse(is.na(x), min(x, na.rm = T)/2, x) else x})

####

pca_res <- mixOmics::pca(X, ncomp = 3, center = T, scale = T)  
PCi <- data.frame(pca_res$x, Groups = Y)

ggplot(PCi, aes(x = PC1, y = PC2, color = Groups)) +
  geom_point(size = 3, alpha = 0.5) + 
  xlab(paste0("PC1 (", round(100*(pca_res$explained_variance)[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(100*(pca_res$explained_variance)[2], 2), "%)")) +
  scale_fill_viridis() + 
  theme_bw()
```

