var.equal = eval(parse(text = input$variance)))$p.value}
stat_G2 <- function(x){t.test(x ~ Group, na.rm=TRUE, alternative=c("two.sided"),
var.equal = eval(parse(text = input$variance)))$estimate[[2]]}
stat_G1 <- function(x){t.test(x ~ Group, na.rm=TRUE, alternative=c("two.sided"),
var.equal = eval(parse(text = input$variance)))$estimate[[1]]}
p <- as.data.frame(apply(FUN=stat, MARGIN = 2, X = iris22[,1:4]))
stat <- function(x){t.test(x ~ Group, na.rm=TRUE, alternative=c("two.sided"))$p.value}
stat_G2 <- function(x){t.test(x ~ Group, na.rm=TRUE, alternative=c("two.sided"))$estimate[[2]]}
stat_G1 <- function(x){t.test(x ~ Group, na.rm=TRUE, alternative=c("two.sided"))$estimate[[1]]}
p <- as.data.frame(apply(FUN=stat, MARGIN = 2, X = iris22[,1:4]))
colnames(p) <- c("P.Value")
p$adj.P.Val <- p.adjust(p$P.Value, method = "fdr")
G2 <- as.data.frame(apply(FUN=stat_G2, MARGIN = 2, X = iris22[,1:4] ))
colnames(G2) <- paste0("Mean ", levels(Group)[2])
G1 <- as.data.frame(apply(FUN=stat_G1, MARGIN = 2, X = iris22[,1:4] ))
colnames(G1) <- paste0("Mean ", levels(Group)[1])
FC <- G2/G1
colnames(FC) <- c("FC (Ratio)")
FC <- round(as.numeric(FC$`FC (Ratio)`,4))
p <- round(cbind(G1,G2, FC, p),4)
View(p)
runApp()
View(G1)
View(G2)
p <- as.data.frame(apply(FUN=stat, MARGIN = 2, X = iris22[,1:4]))
colnames(p) <- c("P.Value")
p$adj.P.Val <- p.adjust(p$P.Value, method = "fdr")
View(p)
G2 <- as.data.frame(apply(FUN=stat_G2, MARGIN = 2, X = iris22[,1:4] ))
colnames(G2) <- paste0("Mean ", levels(Group)[2])
View(G2)
G1 <- as.data.frame(apply(FUN=stat_G1, MARGIN = 2, X = iris22[,1:4] ))
colnames(G1) <- paste0("Mean ", levels(Group)[1])
View(G1)
FC <- data.frame(G2/G1)
colnames(FC) <- c("FC (Ratio)")
View(FC)
FC <- round(as.numeric(FC$`FC (Ratio)`,4))
p <- round(cbind(G1,G2, FC, p),4)
View(p)
FC <- data.frame(G2/G1)
colnames(FC) <- c("FC (Ratio)")
p <- round(cbind(G1,G2, FC, p),4)
iris22<-iris[1:100,]
Group <- iris22$Species
stat <- function(x){t.test(x ~ Group, na.rm=TRUE, alternative=c("two.sided"))$p.value}
stat_G2 <- function(x){t.test(x ~ Group, na.rm=TRUE, alternative=c("two.sided"))$estimate[[2]]}
stat_G1 <- function(x){t.test(x ~ Group, na.rm=TRUE, alternative=c("two.sided"))$estimate[[1]]}
p <- as.data.frame(apply(FUN=stat, MARGIN = 2, X = iris22[,1:4]))
colnames(p) <- c("P.Value")
p$adj.P.Val <- p.adjust(p$P.Value, method = "fdr")
G2 <- as.data.frame(apply(FUN=stat_G2, MARGIN = 2, X = iris22[,1:4] ))
colnames(G2) <- paste0("Mean ", levels(Group)[2])
G1 <- as.data.frame(apply(FUN=stat_G1, MARGIN = 2, X = iris22[,1:4] ))
colnames(G1) <- paste0("Mean ", levels(Group)[1])
FC <- data.frame(G2/G1)
colnames(FC) <- c("FC (Ratio)")
#FC <- round(as.numeric(FC$`FC (Ratio)`,4))
p <- round(cbind(G1,G2, FC, p),4)
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
labels(iris$Species)
levels(iris$Species)[2]
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
to_volcano <- readr::read_csv("/home/pol/Escritorio/dts.csv")
samples_groups <- to_volcano[,1:2]
to_volcano <- to_volcano[,c(3:ncol(to_volcano))]
to_volcano <- to_volcano[,apply(to_volcano,2,function(x) !all(x==0))]
to_volcano <- round(to_volcano,3)
to_volcano <-cbind(samples_groups,to_volcano)
Group2 <- to_volcano[,2]
to_volcanostat <- function(x){t.test(x ~ Group2, na.rm=TRUE, alternative=c("two.sided"),
var.equal = eval(parse(text = input$variance)))$p.value}
to_volcanostat_G2 <- function(x){t.test(x ~ Group2, na.rm=TRUE, alternative=c("two.sided"),
var.equal = eval(parse(text = input$variance)))$estimate[[2]]}
to_volcanostat_G1 <- function(x){t.test(x ~ Group2, na.rm=TRUE, alternative=c("two.sided"),
var.equal = eval(parse(text = input$variance)))$estimate[[1]]}
to_volcano <- as.data.frame(apply(FUN=to_volcanostat, MARGIN = 2, X = to_volcano[,c(3:ncol(to_volcano))] ))
to_volcanostat <- function(x){t.test(x ~ Group2, na.rm=TRUE, alternative=c("two.sided"))$p.value}
to_volcanostat_G2 <- function(x){t.test(x ~ Group2, na.rm=TRUE, alternative=c("two.sided"))$estimate[[2]]}
to_volcanostat_G1 <- function(x){t.test(x ~ Group2, na.rm=TRUE, alternative=c("two.sided"))$estimate[[1]]}
to_volcano <- as.data.frame(apply(FUN=to_volcanostat, MARGIN = 2, X = to_volcano[,c(3:ncol(to_volcano))] ))
colnames(to_volcano) <- c("P.Value")
to_volcano$adj.P.Val <- p.adjust(to_volcano$P.Value, method = "fdr")
to_volcanoG2 <- as.data.frame(apply(FUN=to_volcanostat_G2, MARGIN = 2, X = to_volcano[,c(3:ncol(to_volcano))] ))
to_volcanoG2 <- as.data.frame(apply(FUN=to_volcanostat_G2, MARGIN = 2, X = to_volcano[,c(3:ncol(to_volcano))] ))
to_volcano <- as.data.frame(apply(FUN=to_volcanostat, MARGIN = 2, X = to_volcano[, c(3:ncol(to_volcano))] ))
to_volcano <- as.data.frame(apply(FUN=to_volcanostat, MARGIN = 2, X = to_volcano[c(3:ncol(to_volcano)),] ))
to_volcano <- as.data.frame(apply(FUN=to_volcanostat, MARGIN = 2, X = to_volcano[,c(3:ncol(to_volcano))]))
to_volcanoG2 <- as.data.frame(apply(FUN=to_volcanostat_G2, MARGIN = 2, X = to_volcano[,c(3:ncol(to_volcano))] ))
colnames(to_volcanoG2) <- c("Mean G2")
to_volcanoG1 <- as.data.frame(apply(FUN=to_volcanostat_G1, MARGIN = 2, X = to_volcano[,c(3:ncol(to_volcano))] ))
colnames(to_volcanoG1) <- c("Mean G1")
to_volcanoFC <- data.frame(to_volcanoG2/to_volcanoG1)
colnames(to_volcanoFC) <- c("FC")
to_volcano <- as.data.frame(apply(FUN=to_volcanostat, MARGIN = 2, X = to_volcano[,c(3:ncol(to_volcano))]))
to_volcano <- readr::read_csv("/home/pol/Escritorio/dts.csv")
samples_groups <- to_volcano[,1:2]
to_volcano1 <- to_volcano[,c(3:ncol(to_volcano))]
to_volcano <- to_volcano1[,apply(to_volcano1,2,function(x) !all(x==0))]
to_volcano1 <- round(to_volcano1,3)
to_volcano <-cbind(samples_groups,to_volcano1)
Group2 <- to_volcano[,2]
to_volcanostat <- function(x){t.test(x ~ Group2, na.rm=TRUE, alternative=c("two.sided"))$p.value}
to_volcanostat_G2 <- function(x){t.test(x ~ Group2, na.rm=TRUE, alternative=c("two.sided"))$estimate[[2]]}
to_volcanostat_G1 <- function(x){t.test(x ~ Group2, na.rm=TRUE, alternative=c("two.sided"))$estimate[[1]]}
to_volcano <- as.data.frame(apply(FUN=to_volcanostat, MARGIN = 2, X = to_volcano1))
colnames(to_volcano) <- c("P.Value")
to_volcano$adj.P.Val <- p.adjust(to_volcano$P.Value, method = "fdr")
to_volcanoG2 <- as.data.frame(apply(FUN=to_volcanostat_G2, MARGIN = 2, X = to_volcano1))
colnames(to_volcanoG2) <- c("Mean G2")
to_volcanoG1 <- as.data.frame(apply(FUN=to_volcanostat_G1, MARGIN = 2, X = to_volcano1))
colnames(to_volcanoG1) <- c("Mean G1")
to_volcanoFC <- data.frame(to_volcanoG2/to_volcanoG1)
colnames(to_volcanoFC) <- c("FC")
a <- round(cbind(to_volcanoG1,to_volcanoG2, to_volcanoFC, to_volcano),4)
View(a)
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
?numericInput
runApp()
?formatC
prettyNum(0.05)
prettyNum(0.000005)
runApp()
runApp()
runApp()
runApp()
formatC(0.05)
formatC(0.0005)
formatC(0.00000005)
runApp()
runApp()
runApp()
test<-readr::read_csv("/Users/pol/Dropbox/Shiny_apps/POMA/ST000284/MET_CRC_ST000284.csv")
table(test$Groups)
test<-test[1:132,]
table(test$Groups)
write.csv(test,"/Users/pol/Dropbox/Shiny_apps/POMA/ST000284/MET_CRC_ST000284.csv")
test<-readr::read_csv("/Users/pol/Dropbox/Shiny_apps/POMA/ST000284/COV_CRC_ST000284.csv")
test<-test[1:132,]
write.csv(test,"/Users/pol/Dropbox/Shiny_apps/POMA/ST000284/COV_CRC_ST000284.csv")
runApp()
runApp()
test<-readr::read_csv("/Users/pol/Dropbox/Shiny_apps/POMA/ST000284/MET_CRC_ST000284.csv")
View(test)
test$X1<-NULL
write.csv(test,"/Users/pol/Dropbox/Shiny_apps/POMA/ST000284/MET_CRC_ST000284.csv", row.names = F)
test<-readr::read_csv("/Users/pol/Dropbox/Shiny_apps/POMA/ST000284/COV_CRC_ST000284.csv")
View(test)
test$X1<-NULL
write.csv(test,"/Users/pol/Dropbox/Shiny_apps/POMA/ST000284/COV_CRC_ST000284.csv", row.names = F)
runApp()
runApp()
t.test(iris$Sepal.Length,iris$Sepal.Width,paired = T)$estimate
t.test(iris$Sepal.Length,iris$Sepal.Width,paired = T)$estimate[[1]]
t.test(iris$Sepal.Length,iris$Sepal.Width,paired = F)$estimate[[2]]-t.test(iris$Sepal.Length,iris$Sepal.Width,paired = F)$estimate[[1]]
runApp()
-0.4128	-0.4129
runApp()
runApp()
shiny::runApp()
?topTable
runApp()
runApp()
shiny::runApp()
?formatC
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
auroc
auroc()
auroc("")
auroc
function(auroc)
)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
moveme
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?p
?p
runApp()
runApp()
runApp()
runApp()
runApp()
## Only run examples in interactive R sessions
if (interactive()) {
ui <- fluidPage(
textAreaInput("caption", "Caption", "Data Summary", width = "1000px"),
verbatimTextOutput("value")
)
server <- function(input, output) {
output$value <- renderText({ input$caption })
}
shinyApp(ui, server)
}
runApp()
install.packages("shinyAce")
install.packages("sendmailR")
library(shinyAce)
library(sendmailR)
runApp()
runApp()
library(shiny)
ui <- pageWithSidebar(
headerPanel("fill this and send"),
sidebarPanel(
),
mainPanel(
textInput("name", "Name:", ""),
textInput("body", "Body:", ""),
actionButton("goButton",label = "Send this")
)
)
server <- function(input, output) {
observe({
# Take a dependency on input$goButton
if (input$goButton == 0)
return(NULL)
# Use isolate() to avoid dependency on input$goButton
isolate({
info <- data.frame(subject=paste("New info from:",input$name),
body = info$body)
InfromMe(info)
})
})
}
runApp(list(ui=ui,server=server))
shiny::runApp()
runApp()
runApp()
library(shiny)
ui <- pageWithSidebar(
headerPanel("fill this and send"),
sidebarPanel(
),
mainPanel(
textInput("name", "Name:", ""),
textInput("body", "Body:", ""),
actionButton("goButton",label = "Send this")
)
)
server <- function(input, output) {
InfromMe <- function(info){
from <- "you@account.com"
to <- "recipient@account.com"
subject <- info$subject
body <- info$body
mailControl=list(smtpServer="serverinfo")
sendmail(from=from,to=to,subject=subject,msg=body,control=mailControl)
}
observe({
# Take a dependency on input$goButton
if (input$goButton == 0)
return(NULL)
# Use isolate() to avoid dependency on input$goButton
isolate({
info <- data.frame(subject=paste("New info from:",input$name),
body = info$body)
InfromMe(info)
})
})
}
runApp(list(ui=ui,server=server))
server <- function(input, output) {
observe({
# Take a dependency on input$goButton
if (input$goButton == 0)
return(NULL)
# Use isolate() to avoid dependency on input$goButton
isolate({
info <- data.frame(subject=paste("New info from:",input$name),
body = info$body)
InfromMe <- function(info){
from <- "you@account.com"
to <- "recipient@account.com"
subject <- info$subject
body <- info$body
mailControl=list(smtpServer="serverinfo")
sendmail(from=from,to=to,subject=subject,msg=body,control=mailControl)
}
InfromMe(info)
})
})
}
runApp(list(ui=ui,server=server))
runApp()
if (interactive()) {
# Display an important message that can be dismissed only by clicking the
# dismiss button.
shinyApp(
ui = basicPage(
actionButton("show", "Show modal dialog")
),
server = function(input, output) {
observeEvent(input$show, {
showModal(modalDialog(
title = "Important message",
"This is an important message!"
))
})
}
)
# Display a message that can be dismissed by clicking outside the modal dialog,
# or by pressing Esc.
shinyApp(
ui = basicPage(
actionButton("show", "Show modal dialog")
),
server = function(input, output) {
observeEvent(input$show, {
showModal(modalDialog(
title = "Somewhat important message",
"This is a somewhat important message.",
easyClose = TRUE,
footer = NULL
))
})
}
)
# Display a modal that requires valid input before continuing.
shinyApp(
ui = basicPage(
actionButton("show", "Show modal dialog"),
verbatimTextOutput("dataInfo")
),
server = function(input, output) {
# reactiveValues object for storing current data set.
vals <- reactiveValues(data = NULL)
# Return the UI for a modal dialog with data selection input. If 'failed' is
# TRUE, then display a message that the previous value was invalid.
dataModal <- function(failed = FALSE) {
modalDialog(
textInput("dataset", "Choose data set",
placeholder = 'Try "mtcars" or "abc"'
),
span('(Try the name of a valid data object like "mtcars", ',
'then a name of a non-existent object like "abc")'),
if (failed)
div(tags$b("Invalid name of data object", style = "color: red;")),
footer = tagList(
modalButton("Cancel"),
actionButton("ok", "OK")
)
)
}
# Show modal when button is clicked.
observeEvent(input$show, {
showModal(dataModal())
})
# When OK button is pressed, attempt to load the data set. If successful,
# remove the modal. If not show another modal, but this time with a failure
# message.
observeEvent(input$ok, {
# Check that data object exists and is data frame.
if (!is.null(input$dataset) && nzchar(input$dataset) &&
exists(input$dataset) && is.data.frame(get(input$dataset))) {
vals$data <- get(input$dataset)
removeModal()
} else {
showModal(dataModal(failed = TRUE))
}
})
# Display information about selected data
output$dataInfo <- renderPrint({
if (is.null(vals$data))
"No data selected"
else
summary(vals$data)
})
}
)
}
runApp()
runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
install.packages("RankProd")
installifnot <- function(pckgName){
if (!(require(pckgName, character.only = TRUE))) {
install.packages(pckgName, dep = TRUE)
require(pckgName, character.only = TRUE)
}
}
pk1 <- c("shiny", "shinydashboard", "DT", "reshape2", "ggplot2", "gplots", "scales", "plotly", "readxl", "glmnet", "ggvis", "shinyhelper",
"broom", "readr", "markdown", "ggthemes", "dplyr", "ggrepel", "ggfortify", "shinyBS", "glue", "limma", "tidyr", "mixOmics", "devtools",
"Rcpp", "randomForest", "tidyverse", "ggpubr", "gridExtra", "formattable", "viridis", "shinyAce", "sendmailR")
for (i in 1:length(pk1)){
installifnot(pk1[i])
}
installBiocifnot <- function(pckgName){
if (!(require(pckgName, character.only = TRUE))) {
source("http://Bioconductor.org/biocLite.R")
biocLite(pckgName)
require(pckgName, character.only = TRUE)
}
}
installBiocifnot("impute")
installBiocifnot("RankProd")
devtools::install_github("vqv/ggbiplot")
devtools::install_github("nik01010/dashboardthemes")
runApp()
